{"version":3,"file":"Reflector-3035bc40.js","sources":["../../node_modules/three/examples/jsm/objects/Reflector.js"],"sourcesContent":["import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget,\n\tHalfFloatType,\n\tNoToneMapping,\n\tLinearEncoding\n} from 'three';\n\nclass Reflector extends Mesh {\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\tthis.isReflector = true;\n\n\t\tthis.type = 'Reflector';\n\t\tthis.camera = new PerspectiveCamera();\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || Reflector.ReflectorShader;\n\t\tconst multisample = ( options.multisample !== undefined ) ? options.multisample : 4;\n\n\t\t//\n\n\t\tconst reflectorPlane = new Plane();\n\t\tconst normal = new Vector3();\n\t\tconst reflectorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\t\tconst clipPlane = new Vector4();\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\t\tconst q = new Vector4();\n\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst virtualCamera = this.camera;\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample, type: HalfFloatType } );\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'color' ].value = color;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\tthis.material = material;\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\t// Render\n\t\t\tscope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\t\t\tconst currentOutputEncoding = renderer.outputEncoding;\n\t\t\tconst currentToneMapping = renderer.toneMapping;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\t\t\trenderer.outputEncoding = LinearEncoding;\n\t\t\trenderer.toneMapping = NoToneMapping;\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\trenderer.outputEncoding = currentOutputEncoding;\n\t\t\trenderer.toneMapping = currentToneMapping;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nReflector.ReflectorShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n};\n\nexport { Reflector };\n"],"names":["Reflector","Mesh","geometry","options","PerspectiveCamera","scope","color","Color","textureWidth","textureHeight","clipBias","shader","multisample","reflectorPlane","Plane","normal","Vector3","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","virtualCamera","renderTarget","WebGLRenderTarget","HalfFloatType","material","ShaderMaterial","UniformsUtils","renderer","scene","camera","projectionMatrix","currentRenderTarget","currentXrEnabled","currentShadowAutoUpdate","currentOutputEncoding","currentToneMapping","LinearEncoding","NoToneMapping","viewport"],"mappings":"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"}