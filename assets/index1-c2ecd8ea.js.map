{"version":3,"file":"index1-c2ecd8ea.js","sources":["../../node_modules/three/examples/jsm/objects/Water.js","../../node_modules/three/examples/jsm/objects/Sky.js","../../src/space1.js"],"sourcesContent":["import {\n\tColor,\n\tFrontSide,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget\n} from 'three';\n\n/**\n * Work based on :\n * https://github.com/Slayvin: Flat mirror for three.js\n * https://home.adelphi.edu/~stemkoski/ : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nclass Water extends Mesh {\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\tthis.isWater = true;\n\n\t\tconst scope = this;\n\n\t\tconst textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n\t\tconst textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n\n\t\tconst clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n\t\tconst alpha = options.alpha !== undefined ? options.alpha : 1.0;\n\t\tconst time = options.time !== undefined ? options.time : 0.0;\n\t\tconst normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n\t\tconst sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3( 0.70707, 0.70707, 0.0 );\n\t\tconst sunColor = new Color( options.sunColor !== undefined ? options.sunColor : 0xffffff );\n\t\tconst waterColor = new Color( options.waterColor !== undefined ? options.waterColor : 0x7F7F7F );\n\t\tconst eye = options.eye !== undefined ? options.eye : new Vector3( 0, 0, 0 );\n\t\tconst distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n\t\tconst side = options.side !== undefined ? options.side : FrontSide;\n\t\tconst fog = options.fog !== undefined ? options.fog : false;\n\n\t\t//\n\n\t\tconst mirrorPlane = new Plane();\n\t\tconst normal = new Vector3();\n\t\tconst mirrorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\t\tconst clipPlane = new Vector4();\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\t\tconst q = new Vector4();\n\n\t\tconst textureMatrix = new Matrix4();\n\n\t\tconst mirrorCamera = new PerspectiveCamera();\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight );\n\n\t\tconst mirrorShader = {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib[ 'fog' ],\n\t\t\t\tUniformsLib[ 'lights' ],\n\t\t\t\t{\n\t\t\t\t\t'normalSampler': { value: null },\n\t\t\t\t\t'mirrorSampler': { value: null },\n\t\t\t\t\t'alpha': { value: 1.0 },\n\t\t\t\t\t'time': { value: 0.0 },\n\t\t\t\t\t'size': { value: 1.0 },\n\t\t\t\t\t'distortionScale': { value: 20.0 },\n\t\t\t\t\t'textureMatrix': { value: new Matrix4() },\n\t\t\t\t\t'sunColor': { value: new Color( 0x7F7F7F ) },\n\t\t\t\t\t'sunDirection': { value: new Vector3( 0.70707, 0.70707, 0 ) },\n\t\t\t\t\t'eye': { value: new Vector3() },\n\t\t\t\t\t'waterColor': { value: new Color( 0x555555 ) }\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}`\n\n\t\t};\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tfragmentShader: mirrorShader.fragmentShader,\n\t\t\tvertexShader: mirrorShader.vertexShader,\n\t\t\tuniforms: UniformsUtils.clone( mirrorShader.uniforms ),\n\t\t\tlights: true,\n\t\t\tside: side,\n\t\t\tfog: fog\n\t\t} );\n\n\t\tmaterial.uniforms[ 'mirrorSampler' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\t\tmaterial.uniforms[ 'alpha' ].value = alpha;\n\t\tmaterial.uniforms[ 'time' ].value = time;\n\t\tmaterial.uniforms[ 'normalSampler' ].value = normalSampler;\n\t\tmaterial.uniforms[ 'sunColor' ].value = sunColor;\n\t\tmaterial.uniforms[ 'waterColor' ].value = waterColor;\n\t\tmaterial.uniforms[ 'sunDirection' ].value = sunDirection;\n\t\tmaterial.uniforms[ 'distortionScale' ].value = distortionScale;\n\n\t\tmaterial.uniforms[ 'eye' ].value = eye;\n\n\t\tscope.material = material;\n\n\t\tscope.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\tmirrorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( mirrorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when mirror is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( mirrorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( mirrorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( mirrorWorldPosition );\n\n\t\t\tmirrorCamera.position.copy( view );\n\t\t\tmirrorCamera.up.set( 0, 1, 0 );\n\t\t\tmirrorCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tmirrorCamera.up.reflect( normal );\n\t\t\tmirrorCamera.lookAt( target );\n\n\t\t\tmirrorCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tmirrorCamera.updateMatrixWorld();\n\t\t\tmirrorCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( mirrorCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( mirrorCamera.matrixWorldInverse );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\tmirrorPlane.setFromNormalAndCoplanarPoint( normal, mirrorWorldPosition );\n\t\t\tmirrorPlane.applyMatrix4( mirrorCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant );\n\n\t\t\tconst projectionMatrix = mirrorCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\teye.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\t// Render\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\tscope.visible = false;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification and recursion\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, mirrorCamera );\n\n\t\t\tscope.visible = true;\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport { Water };\n","import {\n\tBackSide,\n\tBoxGeometry,\n\tMesh,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3\n} from 'three';\n\n/**\n * Based on \"A Practical Analytic Model for Daylight\"\n * aka The Preetham Model, the de facto standard analytic skydome model\n * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight\n *\n * First implemented by Simon Wallner\n * http://simonwallner.at/project/atmospheric-scattering/\n *\n * Improved by Martin Upitis\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n *\n * Three.js integration by zz85 http://twitter.com/blurspline\n*/\n\nclass Sky extends Mesh {\n\n\tconstructor() {\n\n\t\tconst shader = Sky.SkyShader;\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tname: 'SkyShader',\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tside: BackSide,\n\t\t\tdepthWrite: false\n\t\t} );\n\n\t\tsuper( new BoxGeometry( 1, 1, 1 ), material );\n\n\t\tthis.isSky = true;\n\n\t}\n\n}\n\nSky.SkyShader = {\n\n\tuniforms: {\n\t\t'turbidity': { value: 2 },\n\t\t'rayleigh': { value: 1 },\n\t\t'mieCoefficient': { value: 0.005 },\n\t\t'mieDirectionalG': { value: 0.8 },\n\t\t'sunPosition': { value: new Vector3() },\n\t\t'up': { value: new Vector3( 0, 1, 0 ) }\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tuniform vec3 sunPosition;\n\t\tuniform float rayleigh;\n\t\tuniform float turbidity;\n\t\tuniform float mieCoefficient;\n\t\tuniform vec3 up;\n\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\t// constants for atmospheric scattering\n\t\tconst float e = 2.71828182845904523536028747135266249775724709369995957;\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\t// wavelength of used primaries, according to preetham\n\t\tconst vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n\t\t// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n\t\tconst vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n\t\t// mie stuff\n\t\t// K coefficient for the primaries\n\t\tconst float v = 4.0;\n\t\tconst vec3 K = vec3( 0.686, 0.678, 0.666 );\n\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n\t\tconst vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n\t\t// earth shadow hack\n\t\t// cutoffAngle = pi / 1.95;\n\t\tconst float cutoffAngle = 1.6110731556870734;\n\t\tconst float steepness = 1.5;\n\t\tconst float EE = 1000.0;\n\n\t\tfloat sunIntensity( float zenithAngleCos ) {\n\t\t\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n\t\t\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n\t\t}\n\n\t\tvec3 totalMie( float T ) {\n\t\t\tfloat c = ( 0.2 * T ) * 10E-18;\n\t\t\treturn 0.434 * c * MieConst;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvWorldPosition = worldPosition.xyz;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n\t\t\tvSunDirection = normalize( sunPosition );\n\n\t\t\tvSunE = sunIntensity( dot( vSunDirection, up ) );\n\n\t\t\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n\t\t\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n\t\t\t// extinction (absorbtion + out scattering)\n\t\t\t// rayleigh coefficients\n\t\t\tvBetaR = totalRayleigh * rayleighCoefficient;\n\n\t\t\t// mie coefficients\n\t\t\tvBetaM = totalMie( turbidity ) * mieCoefficient;\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\tuniform float mieDirectionalG;\n\t\tuniform vec3 up;\n\n\t\tconst vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n\t\t// constants for atmospheric scattering\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\tconst float n = 1.0003; // refractive index of air\n\t\tconst float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n\t\t// optical length at zenith for molecules\n\t\tconst float rayleighZenithLength = 8.4E3;\n\t\tconst float mieZenithLength = 1.25E3;\n\t\t// 66 arc seconds -> degrees, and the cosine of that\n\t\tconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n\t\t// 3.0 / ( 16.0 * pi )\n\t\tconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n\t\t// 1.0 / ( 4.0 * pi )\n\t\tconst float ONE_OVER_FOURPI = 0.07957747154594767;\n\n\t\tfloat rayleighPhase( float cosTheta ) {\n\t\t\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n\t\t}\n\n\t\tfloat hgPhase( float cosTheta, float g ) {\n\t\t\tfloat g2 = pow( g, 2.0 );\n\t\t\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n\t\t\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec3 direction = normalize( vWorldPosition - cameraPos );\n\n\t\t\t// optical length\n\t\t\t// cutoff angle at 90 to avoid singularity in next formula.\n\t\t\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n\t\t\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n\t\t\tfloat sR = rayleighZenithLength * inverse;\n\t\t\tfloat sM = mieZenithLength * inverse;\n\n\t\t\t// combined extinction factor\n\t\t\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n\t\t\t// in scattering\n\t\t\tfloat cosTheta = dot( direction, vSunDirection );\n\n\t\t\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n\t\t\tvec3 betaRTheta = vBetaR * rPhase;\n\n\t\t\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );\n\t\t\tvec3 betaMTheta = vBetaM * mPhase;\n\n\t\t\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n\t\t\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n\t\t\t// nightsky\n\t\t\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]\n\t\t\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]\n\t\t\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n\t\t\tvec3 L0 = vec3( 0.1 ) * Fex;\n\n\t\t\t// composition + solar disc\n\t\t\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n\t\t\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n\t\t\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n\t\t\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n\t\t\tgl_FragColor = vec4( retColor, 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n\n};\n\nexport { Sky };\n","import * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { Water } from 'three/examples/jsm/objects/Water.js';\nimport { Sky } from 'three/examples/jsm/objects/Sky.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\nimport { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';\nimport { BloomPass } from 'three/examples/jsm/postprocessing/BloomPass.js';\nimport { FilmPass } from 'three/examples/jsm/postprocessing/FilmPass.js';\nimport { FocusShader } from 'three/examples/jsm/shaders/FocusShader.js';\nimport { initKeyboardControls } from './keyboardCameraControl.js';\n\n            let container;\n            let camera, scene, renderer;\n            let controls, water, sun, mesh;\n            let model, landmodel;\n            let composer, effectFocus;\n            \n            init();\n            animate();\n\n            function init() {\n\n                container = document.getElementById( 'container' );\n\n                //\n\n                renderer = new THREE.WebGLRenderer();\n                renderer.setPixelRatio( window.devicePixelRatio );\n                renderer.setSize( window.innerWidth, window.innerHeight );\n                renderer.toneMapping = THREE.ACESFilmicToneMapping;\n                container.appendChild( renderer.domElement );\n\n                //\n\n                scene = new THREE.Scene();\n                const loader = new GLTFLoader();\n\n                loader.load('models/John_the_Baptist.gltf', function (gltf) {\n                    gltf.scene.scale.set(0.5, 0.5, 0.5);\n                    gltf.scene.position.set(0, -1.5, 0);\n                    gltf.scene.rotation.y = Math.PI * 4.5;\n                    gltf.scene.rotation.x = 0.08;\n                    model = gltf.scene;\n                    scene.add(model);\n                }, undefined, function (error) {\n                    console.error(error);\n                });\n\n                loader.load('models/land.gltf', function (gltf) {\n                    gltf.scene.scale.set(0.5, 0.5, 0.5);\n                    gltf.scene.position.set(0, 0, 0);\n                    gltf.scene.rotation.y = Math.PI * 4.5;\n                    gltf.scene.rotation.x = 0.08;\n                    landmodel = gltf.scene;\n                    scene.add(landmodel);\n                }, undefined, function (error) {\n                    console.error(error);\n                });\n                             \n\n\n                camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 20000 );\n                camera.position.set( 15, -200,0 );\n\n                //\n\n                sun = new THREE.Vector3();\n\n                // Water\n\n                const waterGeometry = new THREE.PlaneGeometry( 4000, 4000 );\n\n                water = new Water(\n                    waterGeometry,\n                    {\n                        textureWidth: 512,\n                        textureHeight: 512,\n                        waterNormals: new THREE.TextureLoader().load( 'textures/waternormals.jpg', function ( texture ) {\n\n                            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\n                        } ),\n                        sunDirection: new THREE.Vector3(),\n                        sunColor: 0xffffff,\n                        waterColor: 0x001e0f,\n                        distortionScale: 8,\n                        fog: scene.fog !== undefined\n                    }\n                );\n\n                water.rotation.x = - Math.PI / 2;\n                \n\n                scene.add( water );\n\n                // Skybox\n\n                const sky = new Sky();\n                sky.scale.setScalar( 10000 );\n                scene.add( sky );\n\n                const skyUniforms = sky.material.uniforms;\n\n                skyUniforms[ 'turbidity' ].value = 10;\n                skyUniforms[ 'rayleigh' ].value = 2;\n                skyUniforms[ 'mieCoefficient' ].value = 0.005;\n                skyUniforms[ 'mieDirectionalG' ].value = 0.8;\n\n                const now = new Date();\n                const currentTimeRatio = (now.getHours() * 60 + now.getMinutes()) / (24 * 60);\n            \n                const minAzimuth = -180;\n                const maxAzimuth = 180;\n                const currentAzimuth = minAzimuth + currentTimeRatio * (maxAzimuth - minAzimuth);\n            \n                const parameters = {\n                    elevation: 2,\n                    azimuth: currentAzimuth // Set the azimuth based on real-life time\n                };\n\n                const pmremGenerator = new THREE.PMREMGenerator( renderer );\n                let renderTarget;\n\n                function updateSun() {\n\n                    const phi = THREE.MathUtils.degToRad( 90 - parameters.elevation );\n                    const theta = THREE.MathUtils.degToRad( parameters.azimuth );\n\n                    sun.setFromSphericalCoords( 1, phi, theta );\n\n                    sky.material.uniforms[ 'sunPosition' ].value.copy( sun );\n                    water.material.uniforms[ 'sunDirection' ].value.copy( sun ).normalize();\n\n                    if ( renderTarget !== undefined ) renderTarget.dispose();\n\n                    renderTarget = pmremGenerator.fromScene( sky );\n\n                    scene.environment = renderTarget.texture;\n\n                }\n\n                updateSun();\n\n                //\n\n                controls = new OrbitControls( camera, renderer.domElement );\n                controls.maxPolarAngle = Math.PI * 0.495;\n                controls.target.set( 0, 10, 0 );\n                controls.minDistance = 30.0;\n                controls.maxDistance = 100.0;\n                controls.update();\n\n                \t\t\t\t// postprocessing\n\n\t\t\t\tconst renderModel = new RenderPass( scene, camera );\n\t\t\t\tconst effectBloom = new BloomPass( 0.75 );\n\t\t\t\tconst effectFilm = new FilmPass( 0.5, 0.5, 1448, false );\n\n\t\t\t\teffectFocus = new ShaderPass( FocusShader );\n\n\t\t\t\teffectFocus.uniforms[ 'screenWidth' ].value = window.innerWidth * window.devicePixelRatio;\n\t\t\t\teffectFocus.uniforms[ 'screenHeight' ].value = window.innerHeight * window.devicePixelRatio;\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\n\t\t\t\tcomposer.addPass( renderModel );\n\t\t\t\tcomposer.addPass( effectBloom );\n\t\t\t\tcomposer.addPass( effectFilm );\n\t\t\t\tcomposer.addPass( effectFocus );\n\n\n\n                //\n\n                window.addEventListener( 'resize', onWindowResize );\n\n            }\n\n            function onWindowResize() {\n\n                camera.aspect = window.innerWidth / window.innerHeight;\n                camera.updateProjectionMatrix();\n\n                renderer.setSize( window.innerWidth, window.innerHeight );\n\n            }\n\n            function animate() {\n                requestAnimationFrame(animate);\n            \n                if (model) {\n                    const time = performance.now() * 0.002;\n                    model.position.y = -1.5 + Math.sin(time) * 0.6;\n                    model.position.x = Math.sin(time * 0.3) * 0.2;\n                    model.rotation.y = Math.PI * 4.5 + Math.sin(time * 0.5) * 0.1;\n                    model.rotation.x = 0.08 + Math.sin(time * 0.7) * 0.05;\n                    model.rotation.z = Math.sin(time * 0.4) * 0.1;\n                }\n            \n                render();\n            }\n            \n\n            function render() {\n                \n\n                const time = performance.now() * 0.001;\n                water.material.uniforms[ 'time' ].value += 1.0 / 60.0;\n                renderer.render( scene, camera );\n                //composer.render();\n\n            }\n\n            initKeyboardControls(camera);\n"],"names":["Water","Mesh","geometry","options","scope","textureWidth","textureHeight","clipBias","alpha","time","normalSampler","sunDirection","Vector3","sunColor","Color","waterColor","eye","distortionScale","side","FrontSide","fog","mirrorPlane","Plane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","mirrorCamera","PerspectiveCamera","renderTarget","WebGLRenderTarget","mirrorShader","UniformsUtils","UniformsLib","material","ShaderMaterial","renderer","scene","camera","projectionMatrix","currentRenderTarget","currentXrEnabled","currentShadowAutoUpdate","viewport","Sky","shader","BackSide","BoxGeometry","container","controls","water","sun","model","landmodel","composer","effectFocus","init","animate","THREE.WebGLRenderer","THREE.ACESFilmicToneMapping","THREE.Scene","loader","GLTFLoader","gltf","error","THREE.PerspectiveCamera","THREE.Vector3","waterGeometry","THREE.PlaneGeometry","THREE.TextureLoader","texture","THREE.RepeatWrapping","sky","skyUniforms","now","currentTimeRatio","minAzimuth","parameters","pmremGenerator","THREE.PMREMGenerator","updateSun","phi","THREE.MathUtils","theta","OrbitControls","renderModel","RenderPass","effectBloom","BloomPass","effectFilm","FilmPass","ShaderPass","FocusShader","EffectComposer","onWindowResize","render","initKeyboardControls"],"mappings":"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"}